\documentclass{article}

\newcommand{\centersec}[1]{\section*{\hfil #1 \hfil}}
\newcommand{\subcentersec}[1]{\subsection*{\hfil #1 \hfil}}
\newcommand{\subsubcentersec}[1]{\subsubsection*{\hfil #1 \hfil}}

\author{Dylan Johnson}
\title{Attempt}

\begin{document}
  \maketitle

  \centersec{Introduction}
    This is another attempt to write a language; this one will compile for the JVM. I decided to compile
    to the JVM so that a lot of difficult details, such as garbage collection and heap allocation
    can be abstracted away. I may change the target the environment to LLVM and write my own garbage
    collector in the future. However, that is just speculation at this point. Lets get things done one
    at a time. It is going to be named Attempt because that is likely all this will turn out to be.
    In this document will reside the specification for the language.

  \centersec{Feature Plan}
    \subcentersec{Current Plan}
      \begin{itemize}
        \item{enforce proper whitespace indentation and formatting}
        \item{all the standard control flow tools; loops, if else blocks, ect}
        \item{classes with internal member variables and methods; polymorphism via interfaces and data encapsulation}
        \item{add the basic built in types, strings, arrays, integers, bools, floats, ect}
        \item{strong type system}
        \item{all the proper operators for builtin types; +, -, =+, [], ect}
        \item{integration with Java stdlib}
        \item{scopes}
        \item{compile to executable class files}
        \item{a proper namespace and module system}
      \end{itemize}

    \subcentersec{And Beyond}
      \begin{itemize}
        \item{generics}
        \item{port to LLVM}
        \item{write a garbage collector}
        \item{stdlib}
        \item{switch to using impractical unicode symbols such as $ \lambda $ or $ \rightarrow $}
      \end{itemize}

  \centersec{Specification}
    \subcentersec{High Level Formatting}
      \subsubcentersec{Whitespace}
        The only valid whitespace is the one true whitespace: spaces. Spaces and only spaces will be allowed.
        This is because spaces are the purest of all whitespaces and they stay firm to their indentation
        from one editor to the next. All indentation must be in multiples of a given power of two; in other words,
        you cannot mix indentation that indents by one space or two spaces. If you choose and indentation of
        one space, you must stick with it or you will suffer. Your program wont compile.

      \subsubcentersec{Statements}
        Each line of code makes up a statement that can contain one or more expressions. Each
        expression is delimited by a semicolon. The end of each line does not require a semicolon.
        \begin{verbatim}
          # the following expressions are equivalent
          let x: i32 = 3; x += 1
          # or
          let x: i32 = 3
          x += 1
        \end{verbatim}

      \subsubcentersec{Code Blocks}
        The : symbol will be used to state that a new code block will be starting on the next line. The
        : symbol must be used in conjuction with specific language constructs. For example, defining the
        body of a method, if statement, or for loop. They can be nested and can be use in a solitary
        fashion as well. When used in a variable declaration, it is used to specify the type.
        Each block defines its own lexical scope.
        \begin{verbatim}
          if <expression>:
            <expression>
          else:
            <expression>

          # the for loop contains 3 expressions
          for let x: i32 = 0; x < 20; x += 1:
            <expression>

          func foo() -> i32:
            <expression>
            return 3

          <expression>
          : # defines a new block.
            <expressing>
        \end{verbatim}

    \subcentersec{Operators}
      \begin{description}
        \item [assignment] {=}
        \item [add assignment] {+=}
        \item [subtract assignment] {-=}
        \item [multiply assignment] {*=}
        \item [divide assignment] {/=}
        \item [mod assignment] {\%=}
        \item [binary negate assignment] {$ \sim= $ }
        \item [binary right shift assignment] {$ >>= $}
        \item [binary left shift assignment] {$ <<= $}
        \item [binary and assignment] {\&=}
        \item [binary or assignment] {$ |= $}
        \item [binary xor assignment] {$ \hat{}= $}

        \item [add] {+}
        \item [subtract] {-}
        \item [multiply] {*}
        \item [divide] {/}
        \item [mod] {\%}

        \item [array index] {[ ]}

        \item [logical and] {\&\&}
        \item [logical or] {$ || $}
        \item [not] {!}

        \item [equivalence] {==}
        \item [not equivalence] {!=}
        \item [less than] {$ < $}
        \item [less than or equal] {$ <= $}
        \item [more than] {$ > $}
        \item [more than or equal] {$ >= $}

        \item [binary negate] {$ \sim $}
        \item [binary right] {$ >> $}
        \item [binary left] {$ << $}
        \item [binary and] {\&}
        \item [binary or] { $ | $}
        \item [binary xor] {$ \hat{} $}

        \item [scope resolution] {::}

        \item [comment] {\#}
      \end{description}

    \subcentersec{Keywords}
    \subsubsection*{interface}
      This keyword is used to define the beginning of a interface
      definition.
      \begin{verbatim}
        # beginning of a interface
        interface IBar:
          func Baz() -> i32
          func Bar() -> u32
      \end{verbatim}
      All methods defined in a interface are public when
      implemented they cannot be private.

      \subsubsection*{class}
        This keyword is used to define the beginning of a class
        definition.
        \begin{verbatim}
          # beginning of a class
          class Foo(<interfaces to implement>):
            # private member data definitions
            x: i32
            y: u32
            z: Bar
            # public member data definitions
            public y: f32

            # public function
            public func Bar() -> i32:
              <expression>
              return this.x

            func Baz() -> u32:
              <expressions>
              return this.y
        \end{verbatim}

    \subcentersec{Primitive Types}
    \subcentersec{Object System}
      \subsubcentersec{Encapsulation}
      \subsubcentersec{Interfaces}
    \subcentersec{Namespaces and Modules}

  \centersec{Features Implemented}
\end{document}

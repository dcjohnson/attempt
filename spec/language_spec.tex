\documentclass{article}

\newcommand{\centersec}[1]{\section*{\hfil #1 \hfil}}
\newcommand{\subcentersec}[1]{\subsection*{\hfil #1 \hfil}}
\newcommand{\subsubcentersec}[1]{\subsubsection*{\hfil #1 \hfil}}

\author{Dylan Johnson}
\title{Attempt}

\begin{document}
  \maketitle

  \centersec{Introduction}
    This is another attempt to write a language; this one will compile for the JVM. I decided to compile
    to the JVM so that a lot of difficult details, such as garbage collection and heap allocation
    can be abstracted away. I may change the target the environment to LLVM and write my own garbage
    collector in the future. However, that is just speculation at this point. Lets get things done one
    at a time. It is going to be named Attempt because that is likely all this will turn out to be.
    In this document will reside the specification for the language.

  \centersec{Feature Plan}
    \subcentersec{Current Plan}
      \begin{itemize}
        \item{enforce proper whitespace indentation and formatting}
        \item{all the standard control flow tools; loops, if else blocks, ect}
        \item{classes with internal member variables and methods; polymorphism via interfaces and data encapsulation}
        \item{add the basic built in types, strings, arrays, integers, bools, floats, ect}
        \item{strong type system}
        \item{all the proper operators for builtin types; +, -, =+, [], ect}
        \item{integration with Java stdlib}
        \item{scopes}
        \item{compile to executable class files}
        \item{a proper namespace and module system}
      \end{itemize}

    \subcentersec{And Beyond}
      \begin{itemize}
        \item{generics}
        \item{port to LLVM}
        \item{write a garbage collector}
        \item{stdlib}
        \item{switch to using impractical unicode symbols such as $ \lambda $ or $ \rightarrow $}
      \end{itemize}

  \centersec{Specification}
    \subcentersec{High Level Formatting}
      \subsubcentersec{Whitespace}
        The only valid whitespace is the one true whitespace: spaces. Spaces and only spaces will be allowed.
        This is because spaces are the purest of all whitespaces and they stay firm to their indentation
        from one editor to the next. All indentation must be in multiples of a given power of two; in other words,
        you cannot mix indentation that indents by one space or two spaces. If you choose and indentation of
        one space, you must stick with it or you will suffer. Your program wont compile.

      \subsubcentersec{Statements}
        Each line of code makes up a statement that can contain one or more expressions. Each
        expression is delimited by a semicolon. The end of each line cannot end with a semicolon.
        \begin{verbatim}
          # the following expressions are equivalent
          let x: i32 = 3; x += 1
          # or
          let x: i32 = 3
          x += 1
        \end{verbatim}

      \subsubcentersec{Code Blocks}
        The : symbol will be used to state that a new code block will be starting on the next line. The
        : symbol must be used in conjuction with specific language constructs. For example, defining the
        body of a method, if statement, or for loop. They can be nested and can be use in a solitary
        fashion as well. When used in a variable declaration, it is used to specify the type.
        Each block defines its own lexical scope.
        \begin{verbatim}
          if <expression>:
            <expression>
          else:
            <expression>

          # the for loop contains 3 expressions
          for let x: i32 = 0; x < 20; x += 1:
            <expression>

          func foo() -> i32:
            <expression>
            return 3

          <expression>
          : # defines a new block.
            <expressing>
        \end{verbatim}

    \subcentersec{Operators}
      \begin{description}
        \item [assignment] {=}
        \item [add assignment] {+=}
        \item [subtract assignment] {-=}
        \item [multiply assignment] {*=}
        \item [divide assignment] {/=}
        \item [mod assignment] {\%=}
        \item [binary negate assignment] {$ \sim= $ }
        \item [binary right shift assignment] {$ >>= $}
        \item [binary left shift assignment] {$ <<= $}
        \item [binary and assignment] {\&=}
        \item [binary or assignment] {$ |= $}
        \item [binary xor assignment] {$ \hat{}= $}

        \item [add] {+}
        \item [subtract] {-}
        \item [multiply] {*}
        \item [divide] {/}
        \item [mod] {\%}

        \item [array index] {[ ]}

        \item [logical and] {\&\&}
        \item [logical or] {$ || $}
        \item [not] {!}

        \item [equivalence] {==}
        \item [not equivalence] {!=}
        \item [less than] {$ < $}
        \item [less than or equal] {$ <= $}
        \item [more than] {$ > $}
        \item [more than or equal] {$ >= $}

        \item [binary negate] {$ \sim $}
        \item [binary right] {$ >> $}
        \item [binary left] {$ << $}
        \item [binary and] {\&}
        \item [binary or] { $ | $}
        \item [binary xor] {$ \hat{} $}

        \item [scope resolution] {::}

        \item [comment] {\#}
      \end{description}

    \subcentersec{Keywords}
      \subsubsection*{func}
        The \textit{func} keyword is used in function definitions.
        All functions must reside in a class definition.
        \begin{verbatim}
          # returns nothing
          func foo():
            <expressions>

          # returns nothing takes a i32 parameter
          func bar(i: i32):
            <expressions>

          # takes a f32 parameter and returns a f32
          func baz(i: 32) -> f32:
            <expressions>
            let r: f32 = 0
            return r

        \end{verbatim}

      \subsubsection*{interface}
        The \textit{interface} keyword is used to define the beginning of a interface
        definition.
        \begin{verbatim}
          # beginning of a interface
          interface IBar:
            func Baz(x: i32) -> u32
            func Bar() -> i32
        \end{verbatim}
        All methods defined in a interface are public when
        implemented they cannot be private.

      \subsubsection*{class}
        The \textit{class} keyword is used to define the beginning of a class
        definition.
        \begin{verbatim}
          # beginning of a class that implements the IBar interface
          class Foo(IBar, <interfaces to implement>):
            # private member data definitions
            x: i32
            y: u32
            # public member data definitions
            public z: f32

            # the empty constructor
            func Foo():
              x = 0
              y = 0
              z = 0

            # constructor with parameters
            func Foo(x: i32):
              this.x = x
              y = 0
              z = 0

            # part of IBar implementation
            # public function
            public func Bar() -> i32:
              <expression>
              # each method in a class has a reference to the
              # instantiated object
              return this.x

            public func Baz(x: i32) -> u32:
              <expressions>
              return this.y + x

            func Bin() -> f32:
              <expressions>
              return this.y
        \end{verbatim}

        \subsubsection*{entry point class}
          In each executable program, there will be one and only one
          class that has an entry point method. The class can be
          named anything but the \textit{main} method, that also takes
          an array of strings as command line arguments and returns nothing,
          must be unique in the program.
          \begin{verbatim}
            class MainClass:
              func main(args: []string):
                <expressions>
          \end{verbatim}

    \subcentersec{Primitive Types}
    \subcentersec{Object System}
      \subsubcentersec{Encapsulation}
      \subsubcentersec{Interfaces}
    \subcentersec{Namespaces and Modules}

  \centersec{Features Implemented}
\end{document}
